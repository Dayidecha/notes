JAVA系列的后端八股文（JAVA基础、并发、JVM、调优）、中间件八股文（Mysql、redis、Zookeeper、Kafka）、基础知识八股文（计网、操作系统、Linux原理、调优、操作、设计模式、数据库）、框架八股文（Netty、Spring）、分布式八股文（分布式理论、分布式事务、分布式锁、分布式ｉｄ、分布式算法）。


链接：https://leetcode-cn.com/circle/discuss/JlrHm3/



# JAVA基础

### arraylist扩容

```java
  private void grow(int minCapacity) {
        // overflow-conscious code
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1);//新容量扩大到原容量的1.5倍，右移一位相关于原数值除以2。
        if (newCapacity - minCapacity < 0)
            newCapacity = minCapacity;
        if (newCapacity - MAX_ARRAY_SIZE > 0)
            newCapacity = hugeCapacity(minCapacity);
        // minCapacity is usually close to size, so this is a win:
        elementData = Arrays.copyOf(elementData, newCapacity);
    }
————————————————
版权声明：本文为CSDN博主「不善言谈者」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/bushanyantanzhe/article/details/79155677
```



- 当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 `ensureCapacityInternal()` 方法 ，所以 minCapacity 此时为 10。此时，`minCapacity - elementData.length > 0`成立，所以会进入 `grow(minCapacity)` 方法。
- 当 add 第 2 个元素时，minCapacity 为 2，此时 e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，`minCapacity - elementData.length > 0` 不成立，所以不会进入 （执行）`grow(minCapacity)` 方法。
- 添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。











## JAVA基础

### java执行顺序

https://www.cnblogs.com/timetellu/p/11619158.html

　　1、父类的静态变量和静态块赋值（按照声明顺序）
　　2、自身的静态变量和静态块赋值（按照声明顺序）
　　3、main方法
　　3、父类的成员变量和块赋值（按照声明顺序）
　　4、父类构造器赋值
　　5、自身成员变量和块赋值（按照声明顺序）
　　6、自身构造器赋值
　　7、静态方法，实例方法只有在调用的时候才会去执行

### 正确使用equals方法

Object的equals方法容易抛出空指针异常，应该用常量或者确定有值的对象来调用equals。

更推荐使用 `java.util.Objects#equals`(JDK7 引入的工具类)。

```java
Objects.equals(null,"SnailClimb");// false
```



###  整形包装类型值的比较

所有整型包装类对象值的比较必须使用equals方法。

> Integer对象在 **-128 - 127** 之间会从IntegerCache中产生，会复用已有的对象



### BigDecimal

**浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。**

`BigDecimal`用于表示精确的小数，常用于财务计算；

比较`BigDecimal`的值是否相等，必须使用`compareTo()`而不能使用`equals()`。





### **重载和重写**

**重载**

方法重载是指在同一个类中多个方法的**方法名**相同，但各自的**参数**不同；

重载方法返回值类型应该相同。

**重写**

**重写发生在父类子类之间,比如所有类都是继承与Object类的,Object类中本身就有equals,hashcode,toString方法等.在任意子类中定义了重名和同样的参数列表就构成方法重写.**

**重写（override）：一般都是表示子类和父类之间的关系，其主要的特征是：方法名相同，参数相同，但是具体的实现不同。**

**重写的特征：**

（1）方法名必须相同，返回值类型必须相同

（2）参数列表必须相同

（3）访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。

（4）子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。

（5）构造方法不能被重写，

### 继承和多态

**多态**是指，针对某个类型的方法调用，其真正执行的方法取决于运行时期实际类型的方法。

### 抽象类和接口



- 通过`abstract`定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范；
- 定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法；
- 如果不实现抽象方法，则该子类仍是一个抽象类；
- 面向抽象编程使得调用者只关心抽象方法的定义，不关心子类的具体实现。

### Java常见关键字

-----

**final**

1. **final 修饰的类不能被继承，final 类中的所有成员方法都会被隐式的指定为 final 方法；**
2. **final 修饰的方法不能被重写；**
3. **final 修饰的变量是常量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能让其指向另一个对象。**

-----

**static**

1. **修饰成员变量和成员方法:** 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被 static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：`类名.静态变量名` `类名.静态方法名()`
2. **静态代码块:** 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)。 该类不管创建多少对象，静态代码块只执行一次.
3. **静态内部类（static 修饰类的话只能修饰内部类）：** 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非 static 成员变量和方法。
4. **静态导包(用来导入类中的静态资源，1.5 之后的新特性):** 格式为：`import static` 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。

------

###  IO模型

为了保证操作系统的稳定性和安全性，一个**进程的地址空间**划分为 **用户空间（User space）** 和 **内核空间（Kernel space ）** 。

**常见的IO模型**

UNIX 系统下， IO 模型一共有 5 种： **同步阻塞 I/O**、**同步非阻塞 I/O**、**I/O 多路复用**、**信号驱动 I/O** 和**异步 I/O**。

#### **Java中3中常见的IO模型**

**BIO (Blocking I/O)**

同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到在内核把数据拷贝到用户空间。

**NIO (Non-blocking/New I/O)**

Java 中的 NIO 可以看作是 **I/O 多路复用模型**。也有很多人认为，Java 中的 NIO 属于同步非阻塞 IO 模型。

IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间->用户空间）还是阻塞的。

> 目前支持 IO 多路复用的系统调用，有 select，epoll 等等。select 系统调用，是目前几乎在所有的操作系统上都有支持
>
> - **select 调用** ：内核提供的系统调用，它支持一次查询多个系统调用的可用状态。几乎所有的操作系统都支持。
> - **epoll 调用** ：linux 2.6 内核，属于 select 调用的增强版本，优化了 IO 的执行效率。

**IO 多路复用模型，通过减少无效的系统调用，减少了对 CPU 资源的消耗。**

Java 中的 NIO ，有一个非常重要的**选择器 ( Selector )** 的概念，也可以被称为 **多路复用器**。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。

**AIO (Asynchronous I/O)**

AIO 也就是 NIO 2。Java 7 中引入了 NIO 的改进版 NIO 2,它是异步 IO 模型。

异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。



#### select/poll/epoll

select、poll、epoll都是IO多路复用的机制。IO多路复用就是通过一种机制，让一个进程/线程可以监视多个描述符，一旦某个描述符就绪（一般是读写就绪），能够通知应用程序进行相应的读写操作。

**select**（1980年的api)

select维护一个用来存放文件描述符fd的数据结构(fd_set)

select函数调用时，把rset (存储所有的fd(file description 文件描述符），是一个bitmap)拷贝到内核态中，没有数据时会一直判断，阻塞在select时，

有数据来时，把rset(bitmap)置1，select函数会返回

优点：select把fd集合（rset)放到内核态，速度快

缺点：

+ fd集合大小有上限（1024），

+ fd集合不可重用，每次select完要把rset(相当于fd集合的映射)置0，

+ 用户态切换内核态开销大

![image-20210829155116761](C:\Users\y\AppData\Roaming\Typora\typora-user-images\image-20210829155116761.png)



**poll**

poll维护一个存放文件描述符的数据结构(pollfd)

不采用bitmap，采用`pollfd`结构体

解决select的问题：

1. 结构体数组，上限比select很大
2. `pollfd`每次置位revents，可重用





![image-20210829160148721](C:\Users\y\AppData\Roaming\Typora\typora-user-images\image-20210829160148721.png)



**epoll**

epoll使用一个epoll文件描述符管理多个被监听的文件描述符

分三步：

epoll_create：

epoll_ctl：

将用户关心的**文件描述符的事件**存放到**内核**的一个事件表中，这样在用户区和内核区只需要拷贝一次被监听的文件描述符的数据结构(epoll_event)即可。

epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。**第一个参数是epoll_create()的返回值，第二个参数表示动作，用三个宏来表示**：



epoll_wait：

等待事件的产生，类似于select()调用。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。





**总结**

（1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。

（2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。
（3）无论是那种多路复用器,知道IO状态后都需要自己去读取,所以都是**同步**而非异步

**总结2**

**1 用户态将文件描述符参传入内核的方式**
select：创建3个文件描述符集的数据结构(fd_set)并拷贝到内核中，分别监听读、写、异常事件。受单个进程/线程可以打开的文件描述符数量限制，默认是1024个文件描述符。
poll：将传入的文件描述符数据结构(struct pollfd结构体数组)拷贝到内核中进行监听。
epoll：执行epoll_create系统调用时会在内核的缓冲区中建立一颗红黑树以及就绪链表（该链表用于存储已就绪的文件描述符）。接着用户执行的epoll_ctl系统调用添加文件描述符，即在红黑树上增加相应的结点。
**2 内核态检测文件描述符就绪状态的方式**
select：采用轮询方式，线性扫描所有用户关注的文件描述符，如果检测到某个文件描述符已就绪，就修改用户传进来的数据结构fd_set的值。
poll：同样采用轮询方式，线性扫描所有用户关注的文件描述符，如果检测到某个文件描述符就绪，内核就修改文件描述符fd对应的revents的值，并将其加入到内核的等待队列中。
epoll：采用回调方式。在执行epoll_ctl的ADD操作时，不仅将文件描述符放入红黑树上，并且还注册了回调函数，如果某个文件描述符已就绪，它会主动调用回调函数，该回调函数将文件描述符放入到就绪链表中。
**3 找到就绪文件描述符并传递给用户态的方式**
select：将之前传入到内核态的数据结构(fd_set)重新拷贝传出到用户态，并返回就绪的文件描述符数量。但是用户程序并不知道哪些文件描述符是处于就绪态，因此需要在用户程序中对所有的文件描述符再一次进行遍历来判断。
poll：将之前传入到内核态的数据结构(pollfd数组)重新拷贝传出到用户态，并返回就绪的文件描述符数量。用户程序同样不知道哪些文件描述符是处于就绪态，需要遍历判断。
epoll：epoll只需要检测就绪事件链表中有无数据即可，如有，则只需将就绪链表的数据拷贝传出到用户态，并返回就绪的文件描述符数量。由于返回的就是就绪态的文件描述符，因此用户程序不需要通过遍历来判断，而是直接处理即可。
**4 重复监听文件描述符的处理方式**
select：将新的监听文件描述符集合拷贝传入内核中，继续以上步骤。
poll：将新的struct pollfd结构体数组拷贝传入内核中，继续以上步骤。
epoll：无需重新构建红黑树，直接沿用已存在的即可。
**5 三种IO多路复用的适用场景**
select、poll：适合在连接数少并且连接都十分活跃的情况下。

 epoll：适用在连接数很多，活跃连接较少的情况下。

https://blog.csdn.net/u010429831/article/details/118636655

https://www.cnblogs.com/Courage129/p/14295476.html







### 浅拷贝和深拷贝

https://segmentfault.com/a/1190000010648514

+ 浅拷贝：对基本的数据类型进行值传递，对引用数据类型进行引用的传递
+ 深拷贝：对基本的数据类型进行值传递，对引用数据类型，创建一个新对象，并复制其内容
+ 无论浅拷贝或者深拷贝，都需要实现clone()方法，clone方法需要调用该方法的对象实现clonable接口
+ 如何进行一次深拷贝：
  + 序列化该对象，再反序列化回去，序列化的规则需要我们自己来写。
  + 利用 clone() 方法，既然 clone() 方法，是我们来重写的，实际上我们可以对其内的引用类型的变量，再进行一次 clone()。

## 容器

### 快速失败和安全失败

**一、快速失败（fail—fast）**

在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出 Concurrent Modification Exception。

**原理：**迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。每当迭代器使用 hashNext()/next() 遍历下一个元素之前，都会检测 modCount 变量是否为 expectedmodCount 值，是的话就返回遍历；否则抛出异常，终止遍历。

**注意：**这里异常的抛出条件是检测到 **modCount != expectedmodCount** 这个条件。如果集合发生变化时修改 modCount 值刚好又设置为了 expectedmodCount 值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的 bug。

**场景：**java.util 包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。

**二、安全失败（fail—safe）**

采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。

**原理：**由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发 Concurrent Modification Exception。

\>缺点：基于拷贝内容的优点是避免了 Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。

**场景：**java.util.concurrent 包下的容器都是安全失败，可以在多线程下并发使用，并发修改。

### Map

**HashMap 的长度为什么是 2 的幂次方**

**取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length 是 2 的 n 次方；）。”** 并且 **采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。**



#### **hashMap扩容**

https://blog.csdn.net/woshimaxiao1/article/details/83661464



```java
void addEntry(int hash, K key, V value, int bucketIndex) {
        if ((size >= threshold) && (null != table[bucketIndex])) {
            resize(2 * table.length);//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容
            hash = (null != key) ? hash(key) : 0;
            bucketIndex = indexFor(hash, table.length);
        }

        createEntry(hash, key, value, bucketIndex);
    }
```

**当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。**

#### 长度2的次幂

**为何HashMap的数组长度一定是2的次幂？**

为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648 到 2147483647，前后加起来大概 40 亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个 40 亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ `(n - 1) & hash`”。（n 代表数组长度）。这也就解释了 HashMap 的长度为什么是 2 的幂次方。

**这个算法应该如何设计呢？**

我们首先可能会想到采用%取余的操作来实现。但是，重点来了：**“取余(%)操作中如果除数是 2 的幂次则等价于与其除数减一的与(&)操作（也就是说 hash%length==hash&(length-1)的前提是 length 是 2 的 n 次方；）。”** 并且 **采用二进制位操作 &，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是 2 的幂次方。**





**ConcurrentHashMap线程安全的具体实现方式、底层具体实现**

jdk 1.7时，首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。

**`ConcurrentHashMap` 是由 `Segment` 数组结构和 `HashEntry` 数组结构组成**。



jdk1.8时，采用 CAS 和 `synchronized` 来保证并发安全。数据结构跟 HashMap1.8 的结构类似，数组+链表/红黑二叉树。Java 8 在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为 O(N)）转换为红黑树（寻址时间复杂度为 O(log(N))）。

`synchronized` 只锁定当前链表或红黑二叉树的首节点，这样只要 hash 不冲突，就不会产生并发，效率又提升 N 倍。

## 代理模式

代理模式有静态代理（几乎不用）和动态代理两种实现方式

### 动态代理 

相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( *CGLIB 动态代理机制*)。

**从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。**

说到动态代理，Spring AOP、RPC 框架应该是两个不得不的提的，它们的实现都依赖了动态代理。

**动态代理在我们日常开发中使用的相对较小，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。**

就 Java 来说，动态代理的实现方式有很多种，比如 **JDK 动态代理**、**CGLIB 动态代理**等等。



**JDK动态代理**

**在 Java 动态代理机制中 `InvocationHandler` 接口和 `Proxy` 类是核心。**

**JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。**



**CGLIB动态代理**

**在 CGLIB 动态代理机制中 `MethodInterceptor` 接口和 `Enhancer` 类是核心。**

 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。

**JDK 动态代理和 CGLIB 动态代理对比**

1. **JDK 动态代理只能只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。** 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。
2. 就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。

**静态代理和动态代理的对比**

1. **灵活性** ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！
2. **JVM 层面** ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。

**为什么有了JDK动态代理还要CGLIB？**

原文链接：https://blog.csdn.net/sun5769675/article/details/95187532

​    由于JDK的动态代理机制只能代理实现了接口的类，而没有实现接口的类不能不能被JDK动态代理机制代理，为了弥补JDK动态代理机制的这个缺陷，CGLIB针对类来实现代理，它的原理是对指定的目标类（可以实现或者不实现接口）生成一个子类，即：目标类为生成的代理类的父类，并且覆盖父类中的方法来实现目标类增强（采用的是继承），所以该类或方法最好不要声明成final，因为CGLIB原理是动态生成被代理类的子类。

**JDK动态代理和CGLIB的执行效率相比谁更好一点呢？**

关于两者之间的性能的话，JDK动态代理所创建的代理对象，在以前的JDK版本中，性能并不是很高，虽然在高版本中JDK动态代理对象的性能得到了很大的提升，但是他也并不是适用于所有的场景。主要体现在如下的两个指标中：

1. CGLib所创建的动态代理对象在实际运行时候的性能要比JDK动态代理高不少，有研究表明，大概要高10倍；

2. 但是CGLib在创建对象的时候所花费的时间却比JDK动态代理要多很多，有研究表明，大概有8倍的差距；

3. 因此，对于singleton的代理对象或者具有实例池的代理，因为无需频繁的创建代理对象，所以比较适合采用CGLib动态代理，反正，则比较适用JDK动态代理。











# 多线程

在共享内存多处理器环境中，维护共享数据结构的逻辑一致性是一个普遍问题。将这些数据结构用锁保护起来是维持这种一致性的标准技术。需要访问数据的进程（下文中进程，线程，process 都可以看做一个概念，并发运行的程序单位）必须先获取这个数据对应的锁。获取锁之后，进程就独占了对这个数据的访问权知道进行将锁释放。其对锁进行请求的进程都必须进行等待。在持有锁的进程释放锁之后，等待进程的其中一个会获取这把锁，同时其他进程接着等待。

等待进程的等待方式也分两种：被动等待（让出CPU）或者主动等待（自旋）。被动等待就是，进程注册对锁的请求然后阻塞，以便在它等待的时候其他进程可以利用处理器。当锁被释放时，已注册的进程中的其中一个会获取锁。于是被选中的进程就会被解除阻塞在调度就绪时运行。主动等待就是，最典型的就是进程进入一个不断重复检测锁状态并且/或者尝试获取锁对象的紧凑循环（tight loop）。一旦它获取锁对象，就进入受保护数据运行程序。

Anderson[2] 和 Mellor-Crummey 与 Scott[3]提供了对等待方式优缺点的讨论。直观上感觉自旋就是CPU在空转，肯定比阻塞等待浪费性能，但实际上对于小任务，空转时间很短，锁很快就被释放，与阻塞方式在进程状态管理和切换不可忽略的系统开销相比，自旋的代价比阻塞和恢复进程反而小。CLH 锁就是自旋锁的这种被动方式的实践。

队列自旋锁的一个潜在优势就是等待进程不在同一个内存地址上自旋。对于 NUMA 甚至可以达到每个进程都在处理的核心对应的本地内存上自旋，就这降低了各个核心和内存之间互联互通的负载。尤其是在对于某一时间若干等待进程对锁的高争用情况，这点尤其重要。另外队列自旋锁还可以用 FIFO 队列保证对进程的某种公平性和对避免饥饿的保证。

原文链接：https://blog.csdn.net/firebolt100/article/details/82662102

### **常见面试题**

1. **什么是线程和进程?**
    **1.1. 何为进程?**
    **1.2. 何为线程?**

2. **请简要描述线程与进程的关系,区别及优缺点？**
    **2.1. 图解进程和线程的关系**
    **2.2. 程序计数器为什么是私有的?**

  程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**。

  **2.3. 虚拟机栈和本地方法栈为什么是私有的?**

  为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。

  **2.4. 一句话简单了解堆和方法区**

  堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

3. **说说并发与并行的区别?**

4. **为什么要使用多线程呢?**

5. **使用多线程可能带来什么问题?**

   并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、死锁、线程不安全等等。

6. **说说线程的生命周期和状态?**

7. **什么是上下文切换?**

8. **什么是线程死锁?如何避免死锁?**
    **8.1. 认识线程死锁**
    **8.2. 如何避免线程死锁?**

9. **说说 sleep() 方法和 wait() 方法区别和共同点?**

   - 两者最主要的区别在于：**`sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁** 。
   - 两者都可以暂停线程的执行。
   - `wait()` 通常被用于线程间交互/通信，`sleep() `通常被用于暂停执行。
   - `wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify() `或者 `notifyAll()` 方法。`sleep() `方法执行完成后，线程会自动苏醒。或者可以使用 `wait(long timeout)` 超时后线程会自动苏醒。

10. **为什么我们调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？**

    new 一个 Thread，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 但是，直接执行 `run()` 方法，会把 `run()` 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

    **总结： 调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行。**



### **进阶面试题**



1. **synchronized 关键字**
   **1.1.说一说自己对于 synchronized 关键字的了解**
   **1.2. 说说自己是怎么使用 synchronized 关键字**
   **1.3. 构造方法可以使用 synchronized 关键字修饰么？**
   **1.3. 讲一下 synchronized 关键字的底层原理**
   **1.3.1. synchronized 同步语句块的情况**
   **1.3.2. synchronized 修饰方法的的情况**
   **1.3.3.总结**
   **1.4. 说说 JDK1.6 之后的 synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗**

   JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。

   锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。

   级别从低到高依次是:

   1. 无锁状态
   2. 偏向锁状态
   3. 轻量级锁状态
   4. 重量级锁状态

   锁可以升级, 但不能降级. 即: 无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁是单向的.

   https://www.cnblogs.com/wuqinglong/p/9945618.html#5%E4%BC%98%E5%8C%96%E5%90%8Esynchronized%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB

   **1.5. 谈谈 synchronized 和 ReentrantLock 的区别**
   
   **1.5.1. 两者都是可重入锁**
   **1.5.2.synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API**
   **1.5.3.ReentrantLock 比 synchronized 增加了一些高级功能**
   
2. **volatile 关键字**
    **2.1. CPU 缓存模型**
    **2.2. 讲一下 JMM(Java 内存模型)**
    **2.3. 并发编程的三个重要特性**

  3. **原子性** : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。`synchronized` 可以保证代码片段的原子性。

  4. **可见性** ：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。`volatile` 关键字可以保证共享变量的可见性。

  3. **有序性** ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。`volatile` 关键字可以禁止指令进行重排序优化。

  **2.4. 说说 synchronized 关键字和 volatile 关键字的区别**

  `synchronized` 关键字和 `volatile` 关键字是两个互补的存在，而不是对立的存在！

  - **`volatile` 关键字**是线程同步的**轻量级实现**，所以 **`volatile `性能肯定比`synchronized`关键字要好** 。但是 **`volatile` 关键字只能用于变量而 `synchronized` 关键字可以修饰方法以及代码块** 。
  - **`volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。`synchronized` 关键字两者都能保证。**
  - **`volatile`关键字主要用于解决变量在多个线程之间的可见性，而 `synchronized` 关键字解决的是多个线程之间访问资源的同步性。**

  

3. **ThreadLocal**
    **3.1. ThreadLocal 简介**
    **3.2. ThreadLocal 示例**
    **3.3. ThreadLocal 原理**
    **3.4. ThreadLocal 内存泄露问题**



  **线程池策略：**

  如果当前线程池中的线程数目>=corePoolSize，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行；若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务；如果当前线程池中的线程数目达到maximumPoolSize，则会采取任务拒绝策略进行处理；
  如果线程池中的线程数量大于 corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止，直至线程池中的线程数目不大于corePoolSize；如果允许为核心池中的线程设置存活时间，那么核心池中的线程空闲时间超过keepAliveTime，线程也会被终止。

  shutdown()：不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务
  shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务

    **4.1. 为什么要用线程池？**
    
    为了减少每次获取资源的消耗，提高对资源的利用率
    
    线程池的好处：
    
    + 降低资源消耗
    + 提高响应速度
    + 提高线程的客观理性
    
      **4.2. 实现 Runnable 接口和 Callable 接口的区别**
    
    Runnable接口没有返回值，不抛出异常
    
    Callable可以
    
      **4.3. 执行 execute()方法和 submit()方法的区别是什么呢？**
    
    1. **`execute()`方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；**
    2. **`submit()`方法用于提交需要返回值的任务。线程池会返回一个 `Future` 类型的对象，通过这个 `Future` 对象可以判断任务是否执行成功**，
    
      **4.4. 如何创建线程池**
      **4.5 ThreadPoolExecutor 类分析**
      **4.5.1 ThreadPoolExecutor构造函数重要参数分析**
      **4.5.2 ThreadPoolExecutor 饱和策略**
    
      如果当前同时运行的线程数量达到最大线程数（maximumPoolSize)且队列也被放满时，执行策略：
    
    - **`ThreadPoolExecutor.AbortPolicy`：** 抛出 `RejectedExecutionException`来拒绝新任务的处理。
    - **`ThreadPoolExecutor.CallerRunsPolicy`：** 调用执行自己的线程运行任务，也就是直接在调用`execute`方法的线程中运行(`run`)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。
    - **`ThreadPoolExecutor.DiscardPolicy`：** 不处理新任务，直接丢弃掉。
    - **`ThreadPoolExecutor.DiscardOldestPolicy`：** 此策略将丢弃最早的未处理的任务请求。



**线程池状态**

​					shutdown

runing									tidying   ----  terminated								

​				      stop 

1、RUNNING

(1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。 
(02) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！

2、 SHUTDOWN

(1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。 
(2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -> SHUTDOWN。

3、STOP

(1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。 
(2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -> STOP。

4、TIDYING

(1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。 
(2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -> TIDYING。 
当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -> TIDYING。

5、 TERMINATED

(1) 状态说明：线程池彻底终止，就变成TERMINATED状态。 
(2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -> TERMINATED。

**线程池的组成部分**

线程池管理器(ThreadPoolManager):用于创建并管理线程池
工作线程(WorkThread): 线程池中线程
任务接口(Task):每个任务必须实现的接口,以供工作线程调度任务的执行
任务队列:用于存放没有处理的任务 提供一种缓冲机制







​      **4.6 一个简单的线程池 Demo**
​      **4.7 线程池原理分析**

5. **Atomic 原子类**

     **5.1. 介绍一下 Atomic 原子类**

     原子类说简单点就是具有原子/原子操作特征的类。

       **5.2. JUC 包中的原子类是哪 4 类?**

     基本类型

     数组类型

     引用类型

     对象属性的修改类型

       **5.3. 讲讲 AtomicInteger 的使用**
       **5.4. 能不能给我简单介绍一下 AtomicInteger 类的原理**

6. **AQS**（AbstractQueueSynchronizer)
     **6.1. AQS 介绍**
       **6.2. AQS 原理分析**
       **6.2.1. AQS 原理概览**
       **6.2.2. AQS 对资源的共享方式**
       **6.2.3. AQS 底层使用了模板方法模式**
       **6.3. AQS 组件总结**
       **6.4. 用过 CountDownLatch 么？什么场景下用的？**

### volatile关键字

**cpu缓存**：为了解决cpu处理速度和内存处理速度不对等的问题，会造成内存缓存不一致的问题

**cpu为了解决内存缓存不一致性问题可以通过知道缓存一致性协议或用其他手段解决**

**JMM**

![image-20210625130844904](C:\Users\y\AppData\Roaming\Typora\typora-user-images\image-20210625130844904.png)



**`volatile` 关键字 除了防止JVM指令重排，还能保证变量的可见性**

并发编程的三个重要特性：

+ 原子性：一组操作要么全部执行，要么都不执行，`synchronized`保证代码片段的原子性
+ 可见性：一个变量对共享变量进行乐修改，那么另外的线程都立刻知道修改后的最新值
+ 有序性：代码在执行过程中有先后顺序，java在编译器在运行期间的优化，代码执行的顺序不一定是编写时的顺序，`volatile`关键字可以禁止指令进行重新排序优化

**说说 synchronized 关键字和 volatile 关键字的区别**

两者时互补的存在

+ `volatile`关键字是线程同步的轻量级实现，性能要好于`synchronized`，但只能作用与变量，而`synchronized`能作用于代码块和方法

+ `volatile`关键字保证数据的可见性和有序性，但不能保证原子性。

+ `volatile`主要用于解决多个线程之间变量的可见性，`synchronized`用于解决多线程之间对共享资源访问的同步性。

  

### AQS

AQS时一个用来构建锁和同步器的框架

**AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。**

>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。



AQS对资源的共享方式

- Exclusive（独占）：只有一个线程能执行，如`ReentrantLock`。又可分为公平锁和非公平锁：
  - 公平锁：按照线程在队列中的排队顺序，先到者先拿到锁
  - 非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的
- **Share**（共享）：多个线程可同时执行，如` CountDownLatch`、`Semaphore`、 `CyclicBarrier`、`ReadWriteLock` 我们都会在后面讲到。



### CAS

CAS （compareAndSwap），中文叫比较交换，一种无锁原子算法。

过程是这样：它包含 3 个参数 CAS（V，E，N），V表示要更新变量的值，E表示预期值，N表示新值。仅当 V值等于E值时，才会将V的值设为N，如果V值和E值不同，则说明已经有其他线程做两个更新，则当前线程则什么都不做。最后，CAS 返回当前V的真实值。CAS 操作时抱着乐观的态度进行的，它总是认为自己可以成功完成操作。

当多个线程同时使用CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会挂起，仅是被告知失败，并且允许再次尝试，当然也允许实现的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰。

与锁相比，使用CAS会使程序看起来更加复杂一些，但由于其非阻塞的，它对**死锁问题天生免疫**，并且，**线程间的相互影响也非常小**。更为重要的是，使用无锁的方式完全没有锁竞争带来的系统开销，也没有线程间频繁调度带来的开销，因此，他要比基于锁的方式拥有更优越的性能。

### **进程和线程的区别**

- 进程是资源分配的最小单位，线程是CPU调度的最小单位
- 线程在进程下行进（单纯的车厢无法运行）
- 一个进程可以包含多个线程（一辆火车可以有多个车厢）
- 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘）
- 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易）
- 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源）
- 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢）
- 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）
- 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－"互斥锁"
- 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量”



## IO密集和计算密集的线程数

IO密集的线程数应设置为：N*(1+线程等待时间/线程CPU执行时间)

### 对于 synchronized 关键字的了解

**`synchronized` 关键字解决的是多个线程之间访问资源的同步性，`synchronized`关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。**

JDK1.6 对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。

### 怎么使用 synchronized 关键字

**1.修饰实例方法:** 作用于当前对象实例加锁，进入同步代码前要获得 **当前对象实例的锁**

**2.修饰静态方法:** 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 **当前 class 的锁**。因为静态成员不属于任何一个实例对象，是类成员（ *static 表明这是该类的一个静态资源，不管 new 了多少个对象，只有一份*）。所以，如果一个线程 A 调用一个实例对象的非静态 `synchronized` 方法，而线程 B 需要调用这个实例对象所属类的静态 `synchronized` 方法，是允许的，不会发生互斥现象，**因为访问静态 `synchronized` 方法占用的锁是当前类的锁，而访问非静态 `synchronized` 方法占用的锁是当前实例对象锁**。

**3.修饰代码块** ：指定加锁对象，对给定对象/类加锁。`synchronized(this|object)` 表示进入同步代码库前要获得**给定对象的锁**。`synchronized(类.class)` 表示进入同步代码前要获得 **当前 class 的锁**

**双重校验锁实现对象单例**

```java
    //volatile防止指令重排
    private volatile static SingletonDemo uniqueInstance;
    private SingletonDemo(){};

    public static SingletonDemo getInstance(){
        if(uniqueInstance==null){
            //类对象加锁
            synchronized (SingletonDemo.class){
                if(uniqueInstance==null){
                    uniqueInstance = new SingletonDemo();
                }
                return uniqueInstance
            }
        }
        return uniqueInstance;
    }
```

### 讲一下 synchronized 关键字的底层原理

`synchronized` 同步语句块的实现使用的是 `monitorenter` 和 `monitorexit` 指令，其中 `monitorenter` 指令指向同步代码块的开始位置，`monitorexit` 指令则指明同步代码块的结束位置。

`synchronized` 修饰的方法并没有 `monitorenter` 指令和 `monitorexit` 指令，取得代之的确实是 `ACC_SYNCHRONIZED` 标识，该标识指明了该方法是一个同步方法。

**不过两者的本质都是对对象监视器 monitor 的获取。**



### 谈谈 synchronized 和 ReentrantLock 的区别

+ 两者都是可重入锁
+ synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API
+ ReentrantLock 比 synchronized 增加了一些高级功能
  + **等待可中断** : `ReentrantLock`提供了一种能够中断等待锁的线程的机制，通过 `lock.lockInterruptibly()` 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。
  + **可实现公平锁** : `ReentrantLock`可以指定是公平锁还是非公平锁。而`synchronized`只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。`ReentrantLock`默认情况是非公平的，可以通过 `ReentrantLock`类的`ReentrantLock(boolean fair)`构造方法来制定是否是公平的。
  + **可实现选择性通知（锁可以绑定多个条件）**: `synchronized`关键字与`wait()`和`notify()`/`notifyAll()`方法相结合可以实现等待/通知机制。`ReentrantLock`类当然也可以实现，但是需要借助于`Condition`接口与`newCondition()`方法。





### 线程池

#### `ThreadPoolExecutor`构造函数重要参数分析

**`ThreadPoolExecutor` 3 个最重要的参数：**

- **`corePoolSize` :** 核心线程数线程数定义了最小可以同时运行的线程数量。
- **`maximumPoolSize` :** 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- **`workQueue`:** 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。

`ThreadPoolExecutor`其他常见参数:

1. **`keepAliveTime`**:当线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销毁；
2. **`unit`** : `keepAliveTime` 参数的时间单位。
3. **`threadFactory`** :executor 创建新线程的时候会用到。
4. **`handler`** :饱和策略。关于饱和策略下面单独介绍一下。

**`ThreadPoolExecutor` 饱和策略定义:**

如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，`ThreadPoolTaskExecutor` 定义一些策略:

- **`ThreadPoolExecutor.AbortPolicy`：** 抛出 `RejectedExecutionException`来拒绝新任务的处理。
- **`ThreadPoolExecutor.CallerRunsPolicy`：** 调用执行自己的线程运行任务，也就是直接在调用`execute`方法的线程中运行(`run`)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。
- **`ThreadPoolExecutor.DiscardPolicy`：** 不处理新任务，直接丢弃掉。
- **`ThreadPoolExecutor.DiscardOldestPolicy`：** 此策略将丢弃最早的未处理的任务请求。



#### 线程池原理

任务提交 一  核心线程数是否已满           是        等待队列是否已满          是          最大线程池是否已满          是        按照饱和策略来处理

​									否												     否                                                  否                                                     否

​							 创建线程                                           加入等待队列                               创建线程  





#### **线程池状态**

​					shutdown

runing									tidying   ----  terminated								

​				      stop 

1、RUNNING

(1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。 
(02) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！

2、 SHUTDOWN

(1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。 
(2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -> SHUTDOWN。

3、STOP

(1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。 
(2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -> STOP。

4、TIDYING

(1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。 
(2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -> TIDYING。 
当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -> TIDYING。

5、 TERMINATED

(1) 状态说明：线程池彻底终止，就变成TERMINATED状态。 
(2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -> TERMINATED。

**线程池的组成部分**

线程池管理器(ThreadPoolManager):用于创建并管理线程池
工作线程(WorkThread): 线程池中线程
任务接口(Task):每个任务必须实现的接口,以供工作线程调度任务的执行
任务队列:用于存放没有处理的任务 提供一种缓冲机制





​               

###  AtomicInteger 类的原理

AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。



### ThreadLocal

https://blog.csdn.net/weixin_39614877/article/details/110494969

# JVM

### JVM内存区域

**常见面试题**

- **介绍下 Java 内存区域（运行时数据区）**

  堆，方法区，虚拟栈，本地方法栈，程序计数器

- **Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）**

  类加载检查 - 分配内存 - 初始化零值 -设置对象头 - 执行Init方法

  对象头包括两部分：**MarkWord**（哈希码、GC 分代年龄、锁状态标志等等）和**类型指针**，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。

- **对象的访问定位的两种方式（句柄和直接指针两种方式）**

  1.通过句柄 ：Java堆中会划分一块内存作为句柄池，句柄池中包含了对象实例数据和对象类型数据（在方法区）各自的地址信息

  2.通过直接指针：直接指向对象实例（对象实例中包含对象类型的数据的指针）

**概述**

对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。

**运行时数据区域**

jdk1.8之前

![image-20210615113851510](C:\Users\y\AppData\Roaming\Typora\typora-user-images\image-20210615113851510.png)

jdk1.8之后

![image-20210615113913283](C:\Users\y\AppData\Roaming\Typora\typora-user-images\image-20210615113913283.png)



### JVM垃圾回收

**常见面试题**

- **如何判断对象是否死亡（两种方法）。**

  1. 引用计数法：给对象添加一个引用计数器，为0说明不被引用，问题：循环引用

  2. 可达性分析算法：通过一系列GC roots对象作为起点向下搜索，节点走过的路径称为引用链，当一个对象到GC Roots没有引用链时，对象不可用

- **简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。**

  + 软引用的好处：加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory)等问题的产生。

- **如何判断一个常量是废弃常量**

  + 该常量没有被任何对象引用时，废弃

- **如何判断一个类是无用的类**

  + 该类所有的实例都被回收
  + 加载该类的ClassLoader被回收
  + 该类对应的 `java.lang.Class`对象没有被引用

- **垃圾收集有哪些算法，各自的特点？**

  + 标记-清除算法，问题：收集后有大量不连续的碎片
  + 标记-复制算法：把内存分为大小相同的两部分，每次使用一块，清除时把存活的对象复制到另一块，然后把该块空间清理掉
  + 标记-整理算法
  + 分代收集算法

- **HotSpot 为什么要分为新生代和老年代？**

  + 因为有的对象寿命长，有的对象寿命短。应该将寿命长的对象放在一个区，寿命短的对象放在一个区。不同的区采用不同的垃圾收集算法。寿命短的区清理频次高一点，寿命长的区清理频次低一点。提高效率。

- **常见的垃圾回收器有哪些？**

  + Serial收集器
  + ParNew收集器
  + Paraller Scavenge收集器
  + CMS收集器
  + G1收集器

- **介绍一下 CMS,G1 收集器。**

  + CMS收集器是一种以获取最短回收停顿时间为目标的收集器。

    主要过程分为四个步骤：

    + 初始标记
    + 并发标记
    + 重新标记
    + 并发清理

    优点：并发收集，低停顿

    缺点：1.对CPU资源敏感，2.无法处理浮动垃圾，3.使用标记-清楚算法，产生大量空间碎片

- **Minor Gc 和 Full GC 有什么不同呢？**

  + Minor GC：只对新生代进行垃圾收集
  + Full GC：对整个Java堆和方法区进行垃圾收集

### Java Minor GC、Major GC和Full GC之间的区别以及触发条件

- Minor GC
  - Minor GC指新生代GC，即发生在新生代（包括Eden区和Survivor区）的垃圾回收操作，当新生代无法为新生对象分配内存空间的时候，会触发Minor GC。因为新生代中大多数对象的生命周期都很短，所以发生Minor GC的频率很高，虽然它会触发stop-the-world，但是它的回收速度很快。
- Major GC
  - Major GC清理Tenured区，用于回收老年代，出现Major GC通常会出现至少一次Minor GC。
- Full GC
  - Full GC是针对整个新生代、老生代、元空间（metaspace，java8以上版本取代perm gen）的全局范围的GC。Full GC不等于Major GC，也不等于Minor GC+Major GC，发生Full GC需要看使用了什么垃圾收集器组合，才能解释是什么样的垃圾回收。

**MinorGC触发条件**

**虚拟机在进行minorGC之前会判断老年代最大的可用连续空间是否大于新生代的所有对象总空间**

  **1、如果大于的话，直接执行minorGC**

  **2、如果小于，判断是否开启HandlerPromotionFailure，没有开启直接FullGC**

  **3、如果开启了HanlerPromotionFailure, JVM会判断老年代的最大连续内存空间是否大于历次晋升（晋级老年代对象的平均大小）平均值的大小，如果小于直接执行FullGC**

  **4、如果大于的话，执行minorGC**



**FullGC触发条件**

- **老年代空间不足**

- **显示调用System.gc**
- **持久代空间不足**

https://blog.csdn.net/luzhensmart/article/details/103782340



针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：

部分收集 (Partial GC)：

- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。

整堆收集 (Full GC)：收集整个 Java 堆和方法区。





### 类加载的过程

加载-连接-初始化-使用-卸载





### **内存泄漏如何排查**

内存泄漏的几种情况

+ 静态集合类
+ 各种连接，如数据库连接、网络连接和IO连接等使用完后没有close
+ 变量不合理的作用域，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。
+ 内部类持有外部类
+ **改变哈希值**，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露









# JAVA WEB

### MVC框架service dao controller作用

dao层主要做数据持久层的工作

service层主要负责业务模块的应用逻辑设计

controller层主要负责业务模块流程的控制，调用service层的接口来控制业务流程

https://blog.csdn.net/qq_26411021/article/details/79493340

### 请求转发和重定向

请求转发：
`request.getRequestDispatcher(URL地址).forward(request, response)`

处理流程：

1. 客户端发送请求，Servlet做出业务逻辑处理。
2. Servlet调用forword()方法，服务器Servlet把目标资源返回给客户端浏览器。

![img](http://upload-images.jianshu.io/upload_images/938707-aa12b1b1f550df6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

请求转发

2）重定向：
`response.sendRedirect(URL地址)`

处理流程：

1. 客户端发送请求，Servlet做出业务逻辑处理。
2. Servlet调用response.sendReadirect()方法，把要访问的目标资源作为response响应头信息发给客户端浏览器。
3. 客户端浏览器重新访问服务器资源xxx.jsp，服务器再次对客户端浏览器做出响应。

![img](http://upload-images.jianshu.io/upload_images/938707-674142a9bfa22da5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

重定向

以上两种情况，你都需要考虑Servlet处理完后，数据如何在jsp页面上呈现。图例是请求、响应的流程，没有标明数据如何处理、展现。

**转发和重定向的路径问题**

1）使用相对路径在重定向和转发中没有区别
2）重定向和请求转发使用绝对路径时，根/路径代表了不同含义
重定向response.sendRedirect("xxx")是服务器向客户端发送一个请求头信息，由客户端再请求一次服务器。/指的Tomcat的根目录,写绝对路径应该写成"/当前Web程序根名称/资源名" 。如"/WebModule/login.jsp","/bbs/servlet/LoginServlet"
转发是在服务器内部进行的，写绝对路径/开头指的是当前的Web应用程序。绝对路径写法就是"/login.jsp"或"/servlet/LoginServlet"。

**总结**：以上要注意是区分是从服务器外的请求，还在是内部转发，从服务器外的请求，从Tomcat根写起(就是要包括当前Web的根)；是服务器内部的转发，很简单了，因为在当前服务器内，/写起指的就是当前Web的根目录。

**转发和重定向的区别**

1. request.getRequestDispatcher()是容器中控制权的转向，在客户端浏览器地址栏中不会显示出转向后的地址；服务器内部转发，整个过程处于同一个请求当中。
   response.sendRedirect()则是完全的跳转，浏览器将会得到跳转的地址，并重新发送请求链接。这样，从浏览器的地址栏中可以看到跳转后的链接地址。不在同一个请求。重定向，实际上客户端会向服务器端发送两个请求。
   所以转发中数据的存取可以用request作用域：`request.setAttribute(), request.getAttribute()`，重定向是取不到request中的数据的。只能用session。
2. forward()更加高效，在可以满足需要时，尽量使用RequestDispatcher.forward()方法。（思考一下为什么？）
3. RequestDispatcher是通过调用HttpServletRequest对象的getRequestDispatcher()方法得到的，是属于请求对象的方法。
   sendRedirect()是HttpServletResponse对象的方法，即响应对象的方法，既然调用了响应对象的方法，那就表明整个请求过程已经结束了，服务器开始向客户端返回执行的结果。
4. 重定向可以跨域访问，而**转发**是在web服务器内部进行的，**不能跨域访问**。



# 设计模式

## 单例模式



**单例模式一共几种？以及优缺点，运行速度最快的是哪一种？**

https://www.jianshu.com/p/6043b3af3598

1. 懒汉式单例

2. 饿汉式单例

3. 登记式单例（holder)

   通过单例的静态内部类来初始化单例

   内部类只有在外部类被调用才加载，产生Singleton实例；又不用加锁。此模式有上述两个模式的优点，屏蔽了它们的缺点，是最好的单例模式。



# 数据库

## SQL中explain的使用

explain能干嘛：

1. 表的读取顺序
2. 数据读取的操作类型
3. 哪些索引可以使用
4. 哪些索引实际被使用



https://blog.csdn.net/why15732625998/article/details/80388236?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link



https://blog.csdn.net/weixin_39680135/article/details/81084324?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163514072316780274195312%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163514072316780274195312&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-81084324.first_rank_v2_pc_rank_v29&utm_term=sql+explain&spm=1018.2226.3001.4187

## DBMS数据库管理系统

种类

 1. 层次数据库（Hierarchical Database, HDB）

 2. 关系型数据库（Relational Database, RDB）

 3. 面向对象数据库（Object Oriented Database，OODB）

 4. XML数据库（XML Database，XMLDB）

 5. 键值存储系统（Key-Value Store，KVS）

    

**sql语句的优化**

https://www.cnblogs.com/xc-chejj/p/11244748.html

Mysql引擎

InnoDB底层原理



## 索引

**索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash。**



数据库事务



### 索引优化





### MVCC

https://www.cnblogs.com/xuwc/p/13873611.html



## 面试题

**1.谈谈你对Mysql的MVCC的理解？**

MVCC就是多版本并发控制.mvcc是一种并发控制的方法。

在Mysql的InnoDB引擎中指读已提交和可重复读这两种隔离级别下事务对于select操作会访问版本链中的记录过程，InnoDB通过锁机制和MVCC等保证事务的隔离性，只使用于可重复读和读可提交

实现细节：

**版本链**

InnoDB中，聚簇索引记录中有两个隐藏列

+ trx_id：某次事务的id
+ roll_pointer：每次对某条聚簇索引记录**进行修改**时，都会把老版本写入undo日志中，roll_pointer指向上一个版本的记录信息。

此时undo日志中就存在版本链

**ReadView**

执行事务时，会生成一个ReadView

ReadView有以下几个字段：

- `m_ids`：表示在生成`ReadView`时当前系统中活跃的读写事务的`事务id`列表。

- `min_trx_id`：表示在生成`ReadView`时当前系统中活跃的读写事务中最小的`事务id`，也就是`m_ids`中的最小值。

- `max_trx_id`：表示生成`ReadView`时系统中应该分配给下一个事务的`id`值。

  > 小贴士： 注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。比方说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。

- `creator_trx_id`：表示生成该`ReadView`的事务的`事务id`。

  > 小贴士： 我们前边说过，只有在对表中的记录做改动时（执行INSERT、DELETE、UPDATE这些语句时）才会为事务分配事务id，否则在一个只读事务中的事务id值都默认为0。

有了这个`ReadView`，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：

- 如果被访问版本的`trx_id`属性值与`ReadView`中的`creator_trx_id`值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。
- 如果被访问版本的`trx_id`属性值小于`ReadView`中的`min_trx_id`值，表明生成该版本的事务在当前事务生成`ReadView`前已经提交，所以该版本可以被当前事务访问。
- 如果被访问版本的`trx_id`属性值大于或等于`ReadView`中的`max_trx_id`值，表明生成该版本的事务在当前事务生成`ReadView`后才开启，所以该版本不可以被当前事务访问。
- 如果被访问版本的`trx_id`属性值在`ReadView`的`min_trx_id`和`max_trx_id`之间，那就需要判断一下`trx_id`属性值是不是在`m_ids`列表中，如果在，说明创建`ReadView`时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建`ReadView`时生成该版本的事务已经被提交，该版本可以被访问。

如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。

在`MySQL`中，`READ COMMITTED`和`REPEATABLE READ`隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同。

- READ COMMITTED —— 每次读取数据前都生成一个ReadView
- REPEATABLE READ —— 在第一次读取数据时生成一个ReadView

参考：https://www.cnblogs.com/jmliao/p/13204946.html

https://baijiahao.baidu.com/s?id=1629409989970483292&wfr=spider&for=pc





## 表设计

**树形结构数据**





## 逻辑分页和物理分页

https://www.cnblogs.com/yanze/p/10650242.html

**物理分页**

物理分页依赖的是某一物理实体，这个物理实体就是数据库，即：**在查询数据库时在库里执行分页，**

比如MySQL数据库提供了limit关键字，程序员只需要编写带有limit关键字的SQL语句，数据库返回的就是分页结果。

**逻辑(内存)分页**

逻辑分页依赖的是程序员编写的代码。数据库返回的不是分页结果，而是全部数据，然后再由程序员通过代码获取分页数据，（取出全部数据先存于内存中，再取出需要的数据）

常用的操作是一次性从数据库中查询出全部数据并存储到List集合中，因为List集合有序，再根据索引获取指定范围的数据。

实例：

RowBound 属于内存分页，pageHelper属于物理分页。

**对比**

**1.数据库负担**

物理分页每次都访问数据库，逻辑分页只访问一次数据库，物理分页对数据库造成的负担大。

**2.服务器负担**

逻辑分页一次性将数据读取到内存，占用了较大的内容空间，物理分页每次只读取一部分数据，占用内存空间较小。

**3.实时性**

逻辑分页一次性将数据读取到内存，数据发生改变，数据库的最新状态不能实时反映到操作中，实时性差。物理分页每次需要数据时都访问数据库，能够获取数据库的最新状态，实时性强。

**4.适用场合**

逻辑分页主要用于数据量不大、数据稳定的场合，物理分页主要用于数据量较大、更新频繁的场合。







# 计算机网络

## TLS和**SSL**

https://blog.csdn.net/enweitech/article/details/81781405

## 网络七层模型

https://blog.csdn.net/sinat_36192944/article/details/81014033

1. 物理层

   OSI模型的最低层或第一层，规定了激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性，为上层协议提供了一个传输数据的物理媒体。
   在这一层，协议数据单元为比特（bit）。
   在物理层的互联设备包括：集线器（Hub）、中继器（Repeater）等。

2. 数据链路层

   OSI模型的第二层，它控制网络层与物理层之间的通信，其主要功能是在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。
   在这一层，协议数据单元为帧（frame）。
   在数据链路层的互联设备包括：网桥（Bridge）、交换机（Switch）等。

3. 网络层

   OSI模型的第三层，其主要功能是将网络地址翻译成对应的物理地 ，并决定如何将数据从发送方路由到接收方。该层的作用包括：对子网间的数据包进行路由选择，实现拥塞控制、网际互连等功能。
   在这一层，协议数据单元为数据包（packet）。
   在网络层的互联设备包括：路由器（Router）等

4. 传输层

   OSI模型中最重要的一层，是第一个端到端，即主机到主机的层次。其主要功能是负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。 
   在这一层，协议数据单元为数据段（segment）。 
   传输层协议的代表包括：TCP、UDP、SPX等。

5. 会话层

   OSI模型的第五层，管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。其主要功能是建立通信链接，保持会话过程通信链接的畅通，利用在数据中插入校验点来同步两个结点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。

6. 表示层

   OSI模型的第六层，应用程序和网络之间的翻译官，负责对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的解密和加密、压缩、格式转换等。

7. 应用层

   OSI模型的第七层，负责为操作系统或网络应用程序提供访问网络服务的接口。术语“应用层”并不是指运行在网络上的某个特别应用程序，应用层提供的服务包括文件传输、文件管理以及电子邮件的信息处理。



## TCP拥塞控制

**TCP的四种拥塞控制算法**
1.慢开始：
2.拥塞控制（避免）：拥塞窗口cwnd达到ssthresh值时变成线性增长
3.快重传：发送方不需要等重传计时器到期再重传
4.快恢复：收到3个重复确认，认为出现拥塞，ssthrest和拥塞窗口调整为当前的的一半，继续线性增长



## **http和https**

### HTTP1.0、HTTP2.0、HTTP 3.0及HTTPS简要介绍

**3 HTTP 3.0 (QUIC)**

QUIC (Quick UDP Internet Connections), 快速 UDP 互联网连接。

https://blog.csdn.net/glpghz/article/details/106063833

两个主要特性：
（1）线头阻塞(HOL)问题的解决更为彻底：
基于TCP的HTTP/2，尽管从逻辑上来说，不同的流之间相互独立，不会相互影响，但在实际传输方面，数据还是要一帧一帧的发送和接收，一旦某一个流的数据有丢包，则同样会阻塞在它之后传输的流数据传输。而基于UDP的QUIC协议则可以更为彻底地解决这样的问题，让不同的流之间真正的实现相互独立传输，互不干扰。
（2）切换网络时的连接保持：
当前移动端的应用环境，用户的网络可能会经常切换，比如从办公室或家里出门，WiFi断开，网络切换为3G或4G。基于TCP的协议，由于切换网络之后，IP会改变，因而之前的连接不可能继续保持。而基于UDP的QUIC协议，则可以内建与TCP中不同的连接标识方法，从而在网络完成切换之后，恢复之前与服务器的连接。







**token、cookie、sessions**

https://blog.csdn.net/x763795151/article/details/88663106



### 跨域

指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对javascript施加的安全限制。

例如：a页面想获取b页面资源，如果a、b页面的协议、域名、端口、子域名不同，所进行的访问行动都是跨域的，而浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源。



### **长连接和短链接**

https://www.cnblogs.com/gotodsp/p/6366163.html

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

```
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。





## CA如何保证安全

摘要算法用来确保数据没有被篡改，非对称加密算法可以对数据进行加解密，签名算法可以确保数据完整性和抗否认性，把这些算法集合到一起，并搞一套完善的标准，这就是数字证书。

以HTTPS协议为例，浏览器和服务器建立安全连接的步骤如下：

1. 浏览器向服务器发起请求，服务器向浏览器发送自己的数字证书；
2. 浏览器用操作系统内置的Root CA来验证服务器的证书是否有效，如果有效，就使用该证书加密一个随机的AES口令并发送给服务器；
3. 服务器用自己的私钥解密获得AES口令，并在后续通讯中使用AES加密。

上述流程只是一种最常见的单向验证。如果服务器还要验证客户端，那么客户端也需要把自己的证书发送给服务器验证，这种场景常见于网银等。

**小结**

数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准。

数字证书采用链式签名管理，顶级的Root CA证书已内置在操作系统中。

数字证书存储的是公钥，可以安全公开，而私钥必须严格保密。



## **TCP保证可靠性**

https://zhuanlan.zhihu.com/p/112317245

TCP主要提供了检验和、序列号/确认应答、超时重传、最大消息长度、滑动窗口控制等方法实现了可靠性传输。

### **检验和**

通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。TCP在计算检验和时，会在TCP首部加上一个12字节的伪首部。检验和总共计算3部分：TCP首部、TCP数据、TCP伪首部。

### **序列号/确认应答**

这个机制类似于问答的形式。比如在课堂上老师会问你“明白了吗？”，假如你没有隔一段时间没有回应或者你说不明白，那么老师就会重新讲一遍。其实计算机的确认应答机制也是一样的，发送端发送信息给接收端，接收端会回应一个包，这个包就是应答包。

### **超时重传**

超时重传是指发送出去的数据包到接收到确认包之间的时间，如果超过了这个时间会被认为是丢包了，需要重传。那么我们该如何确认这个时间值呢？

我们知道，一来一回的时间总是差不多的，都会有一个类似于平均值的概念。比如发送一个包到接收端收到这个包一共是0.5s，然后接收端回发一个确认包给发送端也要0.5s，这样的两个时间就是RTT（往返时间）。然后可能由于网络原因的问题，时间会有偏差，称为抖动（方差）。

从上面的介绍来看，超时重传的时间大概是比往返时间+抖动值还要稍大的时间。

### **最大消息长度**

在建立TCP连接的时候，双方约定一个最大的长度（MSS）作为发送的单位，重传的时候也是以这个单位来进行重传。理想的情况下是该长度的数据刚好不被网络层分块。

### **滑动窗口控制**

我们上面提到的超时重传的机制存在效率低下的问题，发送一个包到发送下一个包要经过一段时间才可以。所以我们就想着能不能不用等待确认包就发送下一个数据包呢？这就提出了一个滑动窗口的概念。

### **拥塞控制**

窗口控制解决了 两台主机之间因传送速率而可能引起的丢包问题，在一方面保证了TCP数据传送的可靠性。然而如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。为此TCP引入慢启动机制，先发出少量数据，就像探路一样，先摸清当前的网络拥堵状态后，再决定按照多大的速度传送数据。

# 操作系统



## 系统调用

根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：

1. **用户态(user mode)** : 用户态运行的进程或可以直接读取用户程序的数据。
2. **系统态(kernel mode)**: 可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。



系统调用按功能大致分为如下几类：

+ 文件管理：完成文件的读写创建删除等功能
+ 设备管理：完成设备的请求和释放，以及设备启动等功能
+ 进程控制：完成进程的创建、撤销、阻塞以及唤醒等功能
+ 进程通信：完成进程之间的消息传递和信号传递等功能
+ 内存管理：完成内存的分配、回收以及获取作业占用内存大小以及地址等功能





# Linux



## 常用命令

```
ls -l 长格式的形式查看当前目录下所有可见文件的详细属性。其中rwx、r-x、r-x各有功能。
```

Linux 文件系统相关，inode结构，软硬连接，以及文件描述符是什么，怎么去修改，最多允许多少？
Linux 读写数据的整个流程，内核状态切换；Mmap(内存映射)和sendFile函数零拷贝什么原理？
Linux是内存管理是怎么样的？虚存是什么，虚拟地址->物理地址的整个流程是什么？
Linux说一说fork这个函数，返回什么；父子进程之间资源是共享的的吗？父子进程之间怎么用匿名管道通信？
父进程死掉子进程会怎么样？子进程挂掉父进程呢？知道僵尸进程吗，Linux会怎么处理？



## **sendFile函数零拷贝原理**

​	**普通的read和write的传统网络传输过程的步骤**

	关于sendfile与read和write的比较
服务器响应一个http请求的步骤如下：
1.把磁盘文件读入内核缓冲区
2.从内核缓冲区读到内存
3.处理(静态资源不需要处理)
4.发送到网卡的内核缓冲区(发送缓存)
5.网卡发送数据
而sendfile系统调用，省略了2，3步，磁盘文件被直接发送到了网卡的内存缓冲区，减少了数据复制和内核态切换的开销。
sendfile一直都在核心态进行

**一般的网络应用是通过读硬盘数据，然后写数据到socket来完成网络传输的。**
底层实现如下：
1.系统调用read()产生一个上下文切换：从用户模式切换到内核模式，然后DMA(直接内存存取)执行拷贝，把文件数据从硬盘读到一个内核缓冲区里面去。
2.数据从内核缓冲区拷贝到用户态缓冲区，然后系统调用read()返回，这时又产生一个上下文切换：从内核状态切换到用户态。
3.系统调用write()产生一个上下文切换：从用户态切换到内核态，然后把步骤2中读到用户缓冲区的数据拷贝到核心态缓冲区（数据第二次拷贝到核心态缓冲区），不过这次是个不同的核心态缓冲区，这个缓冲区和socket相关联。
4.系统调用write()返回，产生一个上下文切换：从内核态切换到用户态(第4次切换)，然后DMA从内核缓冲区拷贝数据到协议栈(第四次拷贝)。
**关于sendfile进行网络传输的过程**

1.系统调用sendfile()通过DMA把硬盘数据拷贝到内核缓冲区，然后数据直接拷贝到另一个与socket相关的内核缓冲区。(区别)这里没有用户态和核心态之间的切换，在核心态中直接完成了从一个缓冲区到另一个缓冲区的拷贝。
2.DMA把数据从内核缓冲区直接拷贝给协议栈，没有切换，也不需要数据从用户态拷贝到核心态，因为数据就在内核里面。
由此比较，sendfile远比read和write方式在进行数据拷贝时高效。

**mmap和sendfile**

**mmap**

user buffer 和 kernel buffer 共享 index.html。如果你想把硬盘的 index.html 传输到网络中，再也不用拷贝到用户空间，再从用户空间拷贝到 Socket 缓冲区。

  现在，你只需要从内核缓冲区拷贝到 Socket 缓冲区即可，这将减少一次内存拷贝（从 4 次变成了 3 次），但不减少上下文切换次数。

**sendfile**

index.html 要从文件进入到网络协议栈，只需 2 次拷贝：第一次使用 DMA 引擎从文件拷贝到内核缓冲区，第二次从内核缓冲区将数据拷贝到网络协议栈；内核缓存区只会拷贝一些 offset 和 length 信息到 SocketBuffer，基本无消耗。

 **再稍微讲讲 mmap 和 sendFile 的区别。**

1. mmap 适合小数据量读写，sendFile 适合大文件传输。
2. mmap 需要 4 次上下文切换，3 次数据拷贝；sendFile 需要 3 次上下文切换，最少 2 次数据拷贝。
3. sendFile 可以利用 DMA 方式，减少 CPU 拷贝，mmap 则不能（必须从内核拷贝到 Socket 缓冲区）。

在这个选择上：rocketMQ 在消费消息时，使用了 mmap。kafka 使用了 sendFile。

https://www.cnblogs.com/ericli-ericli/articles/12923420.html

**关于sendfile的应用代码–代码作用是把a文件(和客户端程序在同一目录下)传递给服务器端**

## **文件系统**

fs初始化之后，inode以数组的方式存储，还会生成一个map，key为filename，value为inode下标（对应inode在inode数组中的位置）

linux文件存储的最小单位是块，一个块有几个扇区

问题：Inode数组用完

命令

```shell
df -i 查看系统inode使用情况
ls -il 查看当前文件夹 第一个为inode标号
```



## **进程间的通信**

1. 管道

2. 消息队列

3. 共享内存

4. 套接字：两个进程通过3306端口的访问sql

5. 信号量：控制多个进程对一个共享资源的访问

6. 信号

   `kill -l`列出所有信号







# Redis

**redis基本操作**

https://blog.csdn.net/living_ren/article/details/79166436

**redis缓存如何扩容**

一致性哈希算法

https://www.zsythink.net/archives/1182



**如何保证 Redis 缓存与数据库双写一致性**

https://www.cnblogs.com/javastack/p/14323501.html

在做系统优化时，想到了将数据进行分级存储的思路。因为在系统中会存在一些数据，有些数据的实时性要求不高，比如一些配置信息。

基本上配置了很久才会变一次。而有一些数据实时性要求非常高，比如订单和流水的数据。所以这里根据数据要求实时性不同将数据分为三级。

- 第1级：订单数据和支付流水数据；这两块数据对实时性和精确性要求很高，所以不添加任何缓存，读写操作将直接操作数据库。
- 第2级：用户相关数据；这些数据和用户相关，具有读多写少的特征，所以我们使用redis进行缓存。
- 第3级：支付配置信息；这些数据和用户无关，具有数据量小，频繁读，几乎不修改的特征，所以我们使用本地内存进行缓存。

但是只要使用到缓存，无论是本地内存做缓存还是使用 redis 做缓存，那么就会存在数据同步的问题，因为配置信息缓存在内存中，而内存时无法感知到数据在数据库的修改。这样就会造成数据库中的数据与缓存中数据不一致的问题。



**redis的底层数据结构**

https://www.cnblogs.com/ysocean/p/9080942.html#_label5



# Mybatis

https://lvxueyang.vip/post/1bff3c65.html

## ${}和#{}的区别

1）#{}是预编译处理，$ {}是字符串替换。

2）MyBatis在处理#{}时，会将SQL中的#{}替换为?号，使用PreparedStatement的set方法来赋值；MyBatis在处理 $ { } 时，就是把 ${ } 替换成变量的值。

3）使用 #{} 可以有效的防止SQL注入，提高系统安全性。



## resultmap和resulttype的区别

**1、resultType：**当使用resultType做SQL语句返回结果类型处理时，对于SQL语句查询出的字段在相应的pojo中必须有和它相同的字段对应，而resultType中的内容就是pojo在本项目中的位置。

因此对于单表查询的话用resultType是最合适的

**2、resultMap：**当使用resultMap做SQL语句返回结果类型处理时，通常需要在mapper.xml中定义resultMap进行pojo和相应表字段的对应。



## mabatis执行流程

1. 通过Resources加载配置好的mabatis.conf.xml文件

2. 通过SqlSessionFactoryBuilder().builder(is)对象获取工厂类
3. SqlSessionFactory.openSession()获得sqlSession对象
4. jdk动态代理生成mapper接口的代理对象sqlSeesion.getMapper(UserMapper.class)获得操作Mapper

https://blog.csdn.net/qq_38409944/article/details/82494187?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163249483816780366589457%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163249483816780366589457&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-82494187.first_rank_v2_pc_rank_v29&utm_term=mybatis%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B&spm=1018.2226.3001.4187

# Spring框架

### Ioc

**是什么：**

**IoC（Inverse of Control:控制反转）** 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spirng 特有，在其他语言中也有应用。

**解决了什么问题：**

1. 对象之间的耦合度或者说依赖程度降低；
2. 资源变的容易管理；比如你用 Spring 容器提供的话很容易就可以实现一个单例。

IoC 最常见以及最合理的实现方式叫做依赖注入（Dependency Injection，简称 DI）。

### **Spring依赖注入的几种方式**

https://www.php.cn/java/guide/463640.html

1. 构造器注入

   1、引入spring的支持

   2、通过描述具体的类，构造方法和其中的参数，这样spring就可以通过相应的信息用反射的方式创建对象。

   3、在test文件中加载spring配置文件的方法

   ```java
   String configLocation ="applicationContext.xml";
   
   ApplicationContext context = new ClassPathXmlApplicationContext(configLocation);
   
   Role role = context.getBean("role", Role.class);
   ```

2. setter注入

   setter注入是通过setter方法注入

   首先将构造方法设置为无参的构造方法，然后利用setter注入为其设置新的值，这也是通过java的反射技术得以实现的。      

3. 接口注入

   有时候资源并非来自于自身的系统，而是来自于外界，比如说数据库连接资源完全可以在Tomcat下配置，然后通过**JNDI**的方式去获取它，这样的数据库连接资源就属于开发工程外的资源。

   

构造器注入和setter注入是依赖注入的两种主要方式，接口注入是指从别的地方注入的方式。（通过在xml中描述，实现注入）



### AOP

https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486938&idx=1&sn=c99ef0233f39a5ffc1b98c81e02dfcd4&chksm=cea24211f9d5cb07fa901183ba4d96187820713a72387788408040822ffb2ed575d28e953ce7&token=1736772241&lang=zh_CN#rd

AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。

Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 **JDK Proxy**，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 **Cglib** 生成一个被代理对象的子类来作为代理



**aop中通知执行顺序**

https://blog.csdn.net/qq_34412985/article/details/107383520

around - before - around - after - afterreturning

### Spring AOP 和 AspectJ AOP 有什么区别？

**Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。** Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。

Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，

如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。

**AOP 解决了什么问题**

通过上面的分析可以发现，AOP 主要用来解决：在不改变原有业务逻辑的情况下，增强横切逻辑代码，根本上解耦合，避免横切逻辑代码重复。



### @ConfigurationProperties

https://www.cnblogs.com/jimoer/p/11374229.html

**@configurationProperties和@value**

都是读取配置文件属性

 两者获取值的比较（都能从properties和yaml获值）

|                    | @ConfigurationProperties | @value                      |
| ------------------ | ------------------------ | --------------------------- |
| 功能               | 批量注入配置文件的属性   | 一个个指定                  |
| 松散绑定(松散语法) | 支持                     | 不支持                      |
| SPEL               | 不支持                   | 支持(计算,如上age的值所示） |
| JSR303数据校验     | 支持 (邮箱验证）         | 不支持                      |
| 复杂类型封装       | 支持                     | 不支持                      |





### AOP失效的情况



1. 对于传统的web项目来说，通常使用spring和springmvc，因此对于这种项目来讲，他是有两个容器的，一个是spring容器，一般我们会把Service层的东西注入到spring容器中，另一个是springmvc的容器，通常这个容器里注入的是Controller层的东西，这里我们认为spring容器是父容器，springmvc是子容器的概念，然后我们大家都知道通过父子继承关系可知，子容器是可以读取到父容器中的东西，但是父容器是无法读到子容器中的内容，因此基于这个场景，有的同学，把Aop的实现类注入到了spring容器中，并且将Aop的切点表达式配置<aop:config> <aop:pointcut的execution也配到了spring容器的xml，而巧了这位同学要切的类方法，正好是Controller，也就是springmvc容器中的东西，那么这时候问题就来了，aop在初始化时会在自己的容器中寻找能够匹配的类方法，然后给他套上一层代理，此时他在自己能够访问到的spring容器中根本找不到与之匹配的类和方法，因为这些类和方法是在springmvc容器中管理的，因此就没有代理成功。

    **解决：**那么对于上述问题要怎么修改呢？只需要确保你要Aop切的类和方法与你Aop配置切点<aop:config> <aop:pointcut的execution表达式声明是在同一个容器中即可，此时只需要讲这个配置移到springmvc容器的xml中即可

2. 第二种情况与第一种情况有些许的类似，但并不相同，是关于重复扫描的，比如你在spring容器中配置了一个Aop，并且把他托管给spring容器管理，而且execution表达式切的也是spring容器中管理的类和方法，理论上这个时候是好用的，这批execution切到的类都被加了代理，但是巧了，springmvc容器中由于配置的是包路径扫描，恰好把execution表达式切的这一批对象又扫了一遍，又都托管给了springmvc容器，而此时扫到的这批对象，是重新new出来交给springmvc管理的，因此并没有被aop代理，所以在使用时，注入进来的可能是springmvc容器管理的这批对象，因此使用时发现Aop代理失效了。
       **解决：**这个问题的解决方案，就是避免两个容器重复扫描。

3. 被切的方法没有通过代理对象来调用，比如A.a()和A.b()，a方法中调b方法，aop失效

    解决：这个问题如果理解起来困难的话我举个例子，比如A.a(),A.b()是被代理的类和方法，那么当我调用A.a()时，此时a被代理了，成功执行代理类的内容，但还没有完，a()方法中调用了自身的方法b()，此时我们以为b也会被代理类代理，但实际上并没有，因为他是自身方法调用了并不是通过代理类A调用的，如果通过A.b()这种调用方式，那么b是可以被成功代理的。


### **SpringBoot拦截器Interceptor**

一：拦截器的应用场景

1、日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算PV（Page VIEW）等。
2、权限检查：如登录检测，进入处理器检测检测是否登录，如果没有直接返回到登录页面；
3、性能监控：有时候系统在某段时间莫名其妙的慢，可以通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间（如果有反向代理，如apache可以自动记录）；
4、通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，只要是多个处理器都需要的即可使用拦截器实现。
5、OpenSessionInView：如Hibernate，在进入处理器打开SESSION，在完成后关闭SESSION。

二：拦截器与过滤器的区别

1、拦截器是基于Java的反射机制的，而过滤器是基于函数回调。
2、拦截器不依赖与servlet容器，过滤器依赖与servlet容器。
3、拦截器只能对ACTION请求起作用，而过滤器则可以对几乎所有的请求起作用。
4、拦截器可以访问ACTION上下文、值栈里的对象，而过滤器不能访问。
5、在ACTION的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。
6、拦截器可以获取IOC容器中的各个bean，而过滤器就不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。

**使用：**

1.定义

```java
@Component		//声明为springBoot的一个组件，但是并不能起作用，需要在springBoot的配置类中注入
public class TimeInterceptor implements HandlerInterceptor {

	@Override
	public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
			throws Exception {
		System.out.println("TimeInterceptor 进入 Controller 某个方法之前");
		System.out.println("Controller Name:"+((HandlerMethod)handler).getBean().getClass().getName());
		System.out.println("Controller Method Name:"+((HandlerMethod)handler).getMethod().getName());
		request.setAttribute("startTime", new Date().getTime());
		
		/**
		 * boolean 值： 确定了拦截器其余两方法是否执行
		 */
		return true;
	}

	@Override
	public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,
			ModelAndView modelAndView) throws Exception {
		System.out.println("TimeInterceptor 运行 Controller 某个方法时，方法抛出异常将不进入此方法");
		long start = (long) request.getAttribute("startTime");
		System.out.println("TimeInterceptor 处理时长为："+ (new Date().getTime() - start));

	}

	@Override
	public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)
			throws Exception {
		System.out.println("TimeInterceptor 完成 Controller 某个方法");
		long start = (long) request.getAttribute("startTime");
		System.out.println("TimeInterceptor 处理时长为："+ (new Date().getTime() - start));

	}

}

```

2.注入

```java
@Configuration
public class MyWebMvcConfig implements WebMvcConfigurer {

    @Bean
    public MyWebMvcConfig getMyWebMvcConfig(){
        MyWebMvcConfig myWebMvcConfig = new MyWebMvcConfig() {
            @Override
            public void addViewControllers(ViewControllerRegistry registry) {
                registry.addViewController("/").setViewName("alogin");
                registry.addViewController("/login").setViewName("alogin");
                registry.addViewController("/main.html").setViewName("dashboard");
            }
            //注册拦截器
            @Override
            public void addInterceptors(InterceptorRegistry registry) {
                registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns("/**")
                        .excludePathPatterns("/login","/","/user/login");
            }
        };
        return myWebMvcConfig;
    }

```







原文链接：https://blog.csdn.net/qq_35706771/article/details/82957014





### **spring自动装配原理**

**什么是自动转配**

> SpringBoot 定义了一套接口规范，这套规范规定：SpringBoot 在启动时会扫描外部引用 jar 包中的`META-INF/spring.factories`文件，将文件中配置的类型信息加载到 Spring 容器（此处涉及到 JVM 类加载机制与 Spring 的容器知识），并执行类中定义的各种操作。对于外部 jar 来说，只需要按照 SpringBoot 定义的标准，就能将自己的功能装置进 SpringBoot。

**SpringBoot 是如何实现自动装配的？**

- `@EnableAutoConfiguration`：启用 SpringBoot 的自动配置机制
- `@Configuration`：允许在上下文中注册额外的 bean 或导入其他配置类
- `@ComponentScan`： 扫描被`@Component` (`@Service`,`@Controller`)注解的 bean，注解默认会扫描启动类所在的包下所有的类 ，可以自定义不扫描某些 bean。如下图所示，容器中将排除`TypeExcludeFilter`和`AutoConfigurationExcludeFilter`。

**@EnableAutoConfiguration:实现自动装配的核心注解**

`EnableAutoConfiguration` 只是一个简单地注解，自动装配核心功能的实现实际是通过 `AutoConfigurationImportSelector`类。

**AutoConfigurationImportSelector:加载自动装配类**

`AutoConfigurationImportSelector`类的继承体系如下：

```java
public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {
}

public interface DeferredImportSelector extends ImportSelector {
}
public interface ImportSelector {
    String[] selectImports(AnnotationMetadata var1);
}
```

以看出，`AutoConfigurationImportSelector` 类实现了 `ImportSelector`接口，也就实现了这个接口中的 `selectImports`方法，该方法主要用于**获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中**。

```java
private static final String[] NO_IMPORTS = new String[0];

public String[] selectImports(AnnotationMetadata annotationMetadata) {
        // <1>.判断自动装配开关是否打开
        if (!this.isEnabled(annotationMetadata)) {
            return NO_IMPORTS;
        } else {
          //<2>.获取所有需要装配的bean
            AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader);
            AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = this.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);
            return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
        }
    }
```

这里我们需要重点关注一下`getAutoConfigurationEntry()`方法，这个方法主要负责加载自动配置类的。

`getAutoConfigurationEntry()`调用`loadFactoryName()`获取所有自动配置类名

`loadFactoryName()` 调用`SpringFactoriesLoader.loadSpringFactories()`从/META-INF/Spring.factories加载自动配置类



+ **第 1 步**:

  判断自动装配开关是否打开。默认`spring.boot.enableautoconfiguration=true`，可在 `application.properties` 或 `application.yml` 中设置

+ **第 2 步** ：用于获取`EnableAutoConfiguration`注解中的 `exclude` 和 `excludeName`。

+ **第 3 步**：获取需要自动装配的所有配置类，读取`META-INF/spring.factories`

+ **第 4 步** ：经历了一遍筛选，`@ConditionalOnXXX` 中的所有条件都满足，该类才会生效。

**总结**

Spring Boot 通过`@EnableAutoConfiguration`开启自动装配，通过 SpringFactoriesLoader 最终加载`META-INF/spring.factories`中的自动配置类实现自动装配，自动配置类其实就是通过`@Conditional`按需加载的配置类，想要其生效必须引入`spring-boot-starter-xxx`包实现起步依赖

https://www.cnblogs.com/javaguide/p/springboot-auto-config.html





### **Springboot aop的使用**

https://www.cnblogs.com/joy99/p/10941543.html

https://www.cnblogs.com/wangshen31/p/9379197.html

AOP 领域中的特性术语：

- 通知（Advice）: AOP 框架中的增强处理。通知描述了切面何时执行以及如何执行增强处理。
- 连接点（join point）: 连接点表示应用执行过程中能够插入切面的一个点，这个点可以是方法的调用、异常的抛出。在 Spring AOP 中，连接点总是方法的调用。
- 切点（PointCut）: 可以插入增强处理的连接点。
- 切面（Aspect）: 切面是通知和切点的结合。
- 引入（Introduction）：引入允许我们向现有的类添加新的方法或者属性。
- 织入（Weaving）: 将增强处理添加到目标对象中，并创建一个被增强的对象，这个过程就是织入。



使用：

1.导入依赖

```xml
<!--aop依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

2.config中启用aop

```java
@EnableAspectJAutoProxy(proxyTargetClass = true)
```

`proxyTargetClass` 参数决定了代理的机制。当这个参数为 false 时，通过jdk的基于接口的方式进行织入，这时候代理生成的是一个接口对象，将这个接口对象强制转换为实现该接口的一个类，自然就抛出了上述类型转换异常。
反之，`proxyTargetClass` 为 `true`，则会使用 cglib 的动态代理方式。这种方式的缺点是拓展类的方法被`final`修饰时，无法进行织入。

3.定义切面

```java
@Aspect
@Component
public class BuyAspectJ {
    
    @Pointcut("execution(* com.sharpcj.aopdemo.test1.IBuy.buy(..))")
    public void point(){}
    
    @before("point()")
    @Before("execution(* com.example.springboot2demo.AOPDemo.IBuy.buy(..))")
    public void haha(){
        System.out.println("买东西了~");
    }

    @Around("execution(* com.example.springboot2demo.AOPDemo.IBuy.buy(..))")
    public void aroud(ProceedingJoinPoint jp){
        System.out.println("买前");
        try {
            jp.proceed();
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        System.out.println("买后");
    }
}
```

`"execution(* com.example.springboot2demo.AOPDemo.IBuy.buy(..))"`

 `execution`：方法执行时触发

`*`：返回值类型 

`buy(..)`： 方法和参数



### springMVC 参数传递注释

https://blog.csdn.net/justry_deng/article/details/80972817/

**@requestBody和@reqeustParams**

**@PathVariable** 获取url路径上的变量，如`/car/{id}/owner/{username}`   代码中`@PathVariable("id") Integer id`

**@requestBody** 获取请求体中的参数

**@reqeustParams** 获取URL中的参数

@RequestBody与前端传过来的json数据的匹配规则
声明：根据不同的Content-Type等情况,Spring-MVC会采取不同的HttpMessageConverter实现来进行信息转换解析。
          下面介绍的是最常用的：前端以Content-Type 为application/json,传递json字符串数据;后端以@RequestBody
          模型接收数据的情况。

解析json数据大体流程概述：
        Http传递请求体信息，最终会被封装进com.fasterxml.jackson.core.json.UTF8StreamJsonParser中(提示：Spring采用CharacterEncodingFilter设置了默认编码为UTF-8)，然后在public class BeanDeserializer extends BeanDeserializerBase implements java.io.Serializable中，通过 public Object deserializeFromObject(JsonParser p, DeserializationContext ctxt) throws IOException方法进行解析。

### springMVC 跨域请求注解

CrossOrigin - 跨域请求注解，会在响应头上增加跨域请求处理允许，可以在ajax中跨域请求

开启跨域请求 `@CrossOrigin`



### spring解决循环依赖

https://blog.csdn.net/qq_18298439/article/details/88818418

https://blog.csdn.net/fei1234456/article/details/106614971

1. 最好的方法是重构代码，进行解耦
2. 在互相依赖的bean中加上`@Lazy`注解
3. 使用Setter注入

https://blog.csdn.net/fei1234456/article/details/106631249

解决方法：setter方式单例，默认方式（把bean的作用域设置为单例模式，通过sett注入(property)

scope=“prototype” 意思是 每次请求都会创建一个实例对象。

两者的区别是：有状态的bean都使用Prototype作用域，无状态的一般都使用singleton单例作用域。

因为Spring中bean的实例化过程是：先实例化bean对象，再设置对象的属性

spring bean包中的源码为：

```java
/** Cache of singleton objects: bean name --> bean instance（缓存单例实例化对象的Map
集合） */
private final Map<String, Object> singletonObjects = new
ConcurrentHashMap<String, Object>(256);
/** Cache of singleton factories: bean name --> ObjectFactory（单例的工厂Bean缓存集
合） */
private final Map<String, ObjectFactory> singletonFactories = new
HashMap<String, ObjectFactory>(16);
/** Cache of early singleton objects: bean name --> bean instance（早期的单身对象缓
存集合） */
private final Map<String, Object> earlySingletonObjects = new HashMap<String,
Object>(16);
/** Set of registered singletons, containing the bean names in registration
order（单例的实例化对象名称集合） */
private final Set<String> registeredSingletons = new LinkedHashSet<String>(256);
/**
* 添加单例实例
* 解决循环引用的问题
* Add the given singleton factory for building the specified singleton
* if necessary.
* <p>To be called for eager registration of singletons, e.g. to be able to
* resolve circular references.
* @param beanName the name of the bean
* @param singletonFactory the factory for the singleton object
*/
protected void addSingletonFactory(String beanName, ObjectFactory
singletonFactory) {
Assert.notNull(singletonFactory, "Singleton factory must not be null");
synchronized (this.singletonObjects) {
if (!this.singletonObjects.containsKey(beanName)) {
this.singletonFactories.put(beanName, singletonFactory);
this.earlySingletonObjects.remove(beanName);
this.registeredSingletons.add(beanName);
}
}
}
```



### **SpringMVC执行流程**

1、用户发送请求至前端控制器DispatcherServlet
2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。
3、处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。
4、DispatcherServlet通过HandlerAdapter处理器适配器调用处理器
5、执行处理器(Controller，也叫后端控制器)。
6、Controller执行完成返回ModelAndView
7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet
8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器
9、ViewReslover解析后返回具体View
10、DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。
11、DispatcherServlet响应用户

https://blog.csdn.net/qq_42780864/article/details/81461306

# RabbitMQ

## RabbitMQ的消息确认ACK机制

https://www.cnblogs.com/biehongli/p/11789098.html

## RabbitMQ 如何保证消息不丢失

https://www.cnblogs.com/flyrock/p/8859203.html

https://blog.csdn.net/duyusean/article/details/100514060

第一种：生产者弄丢了数据。生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，因为网络问题啥的，都有可能。

第二种：RabbitMQ 弄丢了数据。MQ还没有持久化自己挂了
第三种：消费端弄丢了数据。刚消费到，还没处理，结果进程挂了，比如重启了。

![image-20210913013139450](C:\Users\y\AppData\Roaming\Typora\typora-user-images\image-20210913013139450.png)







# RPC

https://www.cnblogs.com/binarylei/p/14110008.html#22-rpc-%E8%B0%83%E7%94%A8



**SPI机制**

https://www.jianshu.com/p/46b42f7f593c







# 分布式

## **使用分布式锁时考虑哪些问题**

https://www.cnblogs.com/geyifan/archive/2017/03/05/6506168.html#h20

- 获取锁操作的原子性
- 锁与保护共享资源的数据一致性
- 分布式锁的性能
- 可重入
- 公平锁和非公平锁



## 神一样的CAP理论被应用在何方

https://juejin.cn/post/6844903936718012430







# Maven

## 依赖，聚合与继承

https://www.cnblogs.com/gossip/p/5574034.html

### **依赖**

项目中依赖的jar包可以通过依赖的方式(dependencies元素下添加dependency子元素)引入。    

**依赖范围：**

通过控制依赖的范围，可以指定该依赖在什么阶段有效。     

 maven的几种依赖范围(<scope></scope>)

| 名称     | 有效范围                         |
| -------- | -------------------------------- |
| Compile  | 编译，测试，运行。默认的依赖范围 |
| Test     | 测试，如Junit                    |
| Runtime  | 运行，如JDBC                     |
| Provided | 编译，测试，如ServletAPI         |
| System   | 编译，侧四，依赖于系统变量       |

~





## 依赖冲突

https://www.cnblogs.com/linyb-geek/p/13181684.html

